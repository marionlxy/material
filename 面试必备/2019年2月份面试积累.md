## 1.蜜罐信息
```
1，关于java值传递的方式没回答上来
2，如果需要英语基础，准备好一份英语面试的自我介绍
3，mysql最左索引原则(nysql.md 和 mysqlindex，有足够的资料可以参考，尤其是sql优化)
最左前缀原则 没回答上来
```

## 2.兴盛优选
1，锁机制中BlockingQueue没回答上来
2，为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！
new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 
start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**

3，core核心线程，max最大线程
[ThreadPoolExecutor使用详解](https://www.cnblogs.com/zedosu/p/6665306.html)

[你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识](https://segmentfault.com/a/1190000016326062)

[关于线程池的执行原则及配置参数详解](https://gudong.name/2017/05/03/thread-pool-intro.html)

4.线程池的好处引用自 http://ifeve.com/java-threadpool/ 的说明：

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

5.Lock锁的使用的lock与trylock的差别

[Lock锁的使用](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483745&idx=2&sn=6778ee954a19816310df54ef9a3c2f8a&chksm=fd985700caefde16b9970f5e093b0c140d3121fb3a8458b11871e5e9723c5fd1b5a961fd2228&token=1829606453&lang=zh_CN&rd2werd=1#wechat_redirect)

6.AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。


[AbstractQueuedSynchronizer 源码分析](https://www.jianshu.com/p/dbe18cea28e7)

[深入理解AbstractQueuedSynchronizer](https://blog.csdn.net/zzti_erlie/article/details/80036829)
7.避免死锁有哪几种方式
23、死锁,以及解决死锁
死锁产生的四个必要条件
互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。 
不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。 
请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。 
循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所申请地资源。

解决死锁
一是死锁预防，就是不让上面的四个条件同时成立。 
二是合理分配资源。 
三是使用银行家算法，如果该进程请求的资源操作系统剩余量可以满足，那么就分配。

(1)预防死锁：可破坏请求与保持条件，破坏不可抢占条件，破坏循环等待条件，但不可以破坏互斥条件，线程间访问临界资源必须互斥访问；

(2)避免死锁：在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁发生；银行家算法就是如此。

(3)检测死锁：线程发生死锁，此时通过检测机构及时检测死锁发生，采取适当措施，将其从死锁中解脱出来；

(4)解除死锁：检测到死锁，将进程从死锁状态中解脱出来，常用方法为撤消一些进程，回收它们资源，将它们分配给已阻塞的状态线程，使其能继续运行

