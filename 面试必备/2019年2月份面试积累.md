## 1.蜜罐信息
```
1，关于java值传递的方式没回答上来
2，如果需要英语基础，准备好一份英语面试的自我介绍
3，mysql最左索引原则(nysql.md 和 mysqlindex，有足够的资料可以参考，尤其是sql优化)
最左前缀原则 没回答上来
```

## 2.兴盛优选
1，锁机制中BlockingQueue没回答上来
2，为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！
new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 
start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**

3，core核心线程，max最大线程

[你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识](https://segmentfault.com/a/1190000016326062)

[关于线程池的执行原则及配置参数详解](https://gudong.name/2017/05/03/thread-pool-intro.html)

4.线程池的好处引用自 http://ifeve.com/java-threadpool/ 的说明：

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

5.Lock锁的使用的lock与trylock的差别

[Lock锁的使用](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483745&idx=2&sn=6778ee954a19816310df54ef9a3c2f8a&chksm=fd985700caefde16b9970f5e093b0c140d3121fb3a8458b11871e5e9723c5fd1b5a961fd2228&token=1829606453&lang=zh_CN&rd2werd=1#wechat_redirect)

6.AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。


[AbstractQueuedSynchronizer 源码分析](https://www.jianshu.com/p/dbe18cea28e7)

[深入理解AbstractQueuedSynchronizer](https://blog.csdn.net/zzti_erlie/article/details/80036829)
