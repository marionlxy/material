## 2019年自我介绍 ##
```
我叫李小阳，今天29，来自湖南益阳，13年毕业湖南科技大学，
毕业之后，去北京工作三年有余，17年回的长沙，目前在爱尔眼科集团下面的一家子公司担任java高级工程师一职
在我将近6年的职业生涯里，前前后后参与了许多大中型项目，都担任项目开发的主要核心人员
1,零售电商类项目，参与过北京王府井全渠道电商项目（当时主要负责营销中心消息队列数据同步）
2,金融类项目，参与过湖北内部资金交易系统(主要负责核心业务开发)
3,移动互联网项目，参与过目邻app，爱尔眼科互联网医院等(做过前后端开发)
总之，这一路走过来积累了很多sap经验，我希望我的技术积累和实际业务经验积累，能担任贵公司的高级java一职。
```


## 01.消息队列  ##
```
1.1.为什么使用消息队列？
核心：解耦、异步、削峰，业务处理允许一定的延时
1.2 消息队列有什么优缺点
优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。

缺点有以下几个：

系统可用性降低
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？。
系统复杂度提高
硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。
一致性问题
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。
所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的

1.3、如何保证消息队列是高可用的？
集群模式，master-slave

1.4、如何保证消息不被重复消费？=如何保证消息不被重复消费？
其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。 
(1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。
(2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。 
(3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将 以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可
```